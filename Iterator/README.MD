# Resources (URL, VIDEOS, BLOGs)
<a href="https://refactoring.guru/es/design-patterns/iterator">Refactoring.guru</a>
<a href="https://www.makigas.es/series/patrones-de-diseno/patron-iterator">Makigas | El patr贸n Iterator</a>

## Explicaci贸n por ChatGPT
###  驴Qu茅 es el patr贸n Iterator?
Es un patr贸n de comportamiento que te permite recorrer una colecci贸n de elementos sin exponer su estructura interna (por ejemplo, una lista, un 谩rbol, una base de datos, etc.).

Es como si tuvieras una caja con cosas adentro y una mano especial que te ayuda a sacar una por una, sin que tengas que abrir la caja y ver c贸mo est谩n organizadas.

###  Ejemplo real simple
Imagina que tienes una colecci贸n de canciones en una playlist.

T煤 no necesitas saber c贸mo est谩n almacenadas esas canciones dentro del reproductor (si es una lista, un array, una base de datos, etc.), solo necesitas una manera de ir canci贸n por canci贸n (por ejemplo, con "siguiente" y "anterior").

El iterador es esa funcionalidad que te permite recorrer la lista de canciones sin preocuparte por c贸mo est谩 hecha por dentro.

###  驴Para qu茅 me sirve?
Para recorrer estructuras complejas (listas, 谩rboles, gr谩ficos) de forma sencilla.

Para ocultar detalles internos de la colecci贸n.

Para crear m煤ltiples formas de recorrer la misma colecci贸n (por ejemplo, de atr谩s para adelante, solo pares, etc.).

###  驴Cu谩ndo usarlo?
Cuando tienes una colecci贸n de objetos y necesitas recorrerla de forma ordenada.

Cuando no quieres que el usuario del c贸digo sepa c贸mo est谩 organizada la colecci贸n.

Cuando quieres tener diferentes formas de iterar sobre una colecci贸n (normal, reversa, filtrando, etc.).

###  Resumen corto
El patr贸n Iterator te permite recorrer elementos de una colecci贸n sin saber c贸mo est谩n organizados. Es 煤til cuando trabajas con estructuras de datos y quieres recorrerlas de forma sencilla y segura.

### Mi Resumen
El patr贸n Iterator se usa cuando quieres recorrer una colecci贸n de elementos de forma personalizada, pero sin que el cliente (quien usa tu clase) tenga que saber c贸mo funciona internamente ese recorrido.

El cliente solo necesita usar el iterador y llamar next() o hacer un for, sin preocuparse por 铆ndices, filtros, ni estructura interna.